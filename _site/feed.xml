<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Metals, Magnets, and Miscellaneous Materials</title>
    <description>Blog Introduction to Computational Condensed Matter Physics</description>
    <link>/M4/</link>
    <atom:link href="/M4/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 17 Feb 2016 02:31:52 +0900</pubDate>
    <lastBuildDate>Wed, 17 Feb 2016 02:31:52 +0900</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Jacobi Transformation of a Symmetric Matrix</title>
        <description>&lt;p&gt;&lt;i&gt;Based on Numerical Recipes in C++, Sec 11.1&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;So you want to diagonalize a matrix, do you?
Well, if you have a tiny symmetric matrix, you REALLY want to write up the algorithm by hand, and don’t want to spend much time trying to understand the algorithm, then you have come to the right place.&lt;/p&gt;

&lt;p&gt;Otherwise, use LAPACK/BLAS to call a highly optimized routine that can work extremely quickly on large matrices.  Julia has those libraries built in already.  Even if you do call those matrices, you can make them work better by understanding what’s going on underneath the hood, which is why we are going through this now.&lt;/p&gt;

&lt;p&gt;Start with a base Rotation Matrix of the Form
\begin{equation}
    P_{pq} =
    \begin{pmatrix}
           1&amp;amp; &amp;amp;  &amp;amp;  &amp;amp; &amp;amp; &amp;amp; &amp;amp; 0 \&lt;br /&gt;
           &amp;amp; \ddots &amp;amp; &amp;amp; &amp;amp; &amp;amp;  &amp;amp;  \&lt;br /&gt;
            &amp;amp; &amp;amp; c &amp;amp; \cdots &amp;amp; s &amp;amp; &amp;amp; \&lt;br /&gt;
                &amp;amp; &amp;amp;\vdots&amp;amp; 1 &amp;amp; \vdots &amp;amp; &amp;amp; \&lt;br /&gt;
               &amp;amp; &amp;amp; -s &amp;amp; \cdots &amp;amp; c &amp;amp; &amp;amp;  \&lt;br /&gt;
               &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \ddots &amp;amp;  \&lt;br /&gt;
               0 &amp;amp; &amp;amp; &amp;amp; &amp;amp;  &amp;amp; &amp;amp; 1\&lt;br /&gt;
    \end{pmatrix}
\end{equation}&lt;/p&gt;

&lt;p&gt;From our starting arbitrary symmetric A,
\begin{equation}
A^{T} = A
\end{equation}
we will run a series of transformations,
\begin{equation}
A^{\prime}= P^{T}_{pq} \cdot A \cdot P_{pq}
\end{equation}
where each iteration brings A closer to diagonal form.  Thus in our implementing our algorithm, we need to determine two things&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; The values of c and s
&lt;li&gt; The pattern of sweeping p and q

And in the end we will need to finally determine if this actually converges, and if has any sort of efficiency.

So lets expand one transformation, and we if we can solve for $c$ and $s$.

\begin{align}
a^{\prime}\_{rp} &amp;amp; = c a\_{rp} - s a\_{rq} \\\\
a^{\prime}\_{rq} &amp;amp; = c a\_{rq} + s a\_{rp} \\\\
a^{\prime}\_{pp} &amp;amp; = c\^2 a\_{pp} + s\^2 a\_{qq} -2 sc a\_{pq} \\\\
a^{\prime}\_{qq} &amp;amp; = s\^2 a\_{qq} + c\^2 a\_{qq} + 2sc a\_{pq} \\\\
a^{\prime}\_{pq} &amp;amp; = \left( c\^2-s\^2 \right) a\_{pq} + sc \left(a\_{pq} - a\_{qq} \right)\\\\
\end{align}

## Determining $s$ and $c$
Given we specifically want $a\^{\prime}\_{pq}$ to be zero, we re-arrange the last equation,
\begin{equation}
        \frac{c\^2-s\^2}{2 sc} = \frac{a\_{pq}-a\_{qq}}{2 a\_{pq}} =\theta
\end{equation}
At first glance, this equation might not look easier to solve for $s$ or $c$.  Second either. We define a new parameter $t = s/c$, which now makes the equation,
\begin{equation}
\frac{1-t^2}{2 t} = \theta \;\;\;\; \implies \;\;\; t^2 -2 \theta t -1=0,
\end{equation}
now quite easily solvable by our friendly quadratic formula.  Though the book does recommend using form that pulls out smaller root through
\begin{equation}
t=\frac{\text{sgn}(\theta)}{|\theta| + \sqrt{\theta^2 + 1} }.
\end{equation}
Then reverse solve back to
\begin{align}
c&amp;amp;=\frac{1}{\sqrt{t^2+1}}\\
s&amp;amp;=tc
\end{align}

Though we could use the expressions above, if we simplify them with our new expressions for $c$ and $s$ analytically, we reduce computational load and round off error. These new expressions are
\begin{align}
a\^{\prime}\_{pq} &amp;amp; = 0\\\\
a\^{\prime}\_{qq} &amp;amp; = a\_{qq} + t a\_{qp} \\\\
a\^{\prime}\_{pp} &amp;amp;= a\_{pp} - t a\_{pq} \\\\
a\^{\prime}\_{rp} &amp;amp;= a\_{rp} - s \left( a\_{rq} +\tau a\_{rp} \right) \\\\
a\^{\prime}\_{rq} &amp;amp;= a\_{rq} + s \left( a\_{rp} -\tau a\_{rq} \right)\\\\
\end{align}
with the new variable
\begin{equation}
\tau = \frac{s}{1+c}
\end{equation}

## Convergence

The sum of the squares of the off diagonal elements ,choosen in either upper or lower triagnles arbitrarily,
\begin{equation}
S=\sum\limits_{r &amp;lt; s} |a\_{rs}|^2
\end{equation}

## Eigenvectors

By forming a product of every rotation matrix, we also come to approximate the matrix $V$ where
\begin{equation}
D = V^{T} \cdot A \cdot V
\end{equation}
and $D$ is the diagonal form of $A$.  $V$ is computed through itereative computation
\begin{align}
V^{\prime} &amp;amp; = V \cdot P_i \\\\
v^{\prime}\_{rs} &amp;amp;= v\_{rs} \\\\
v^{\prime}\_{rp} &amp;amp;= c v\_{rp} - s v\_{rq} \\\\
v^{\prime}\_{rq} &amp;amp;= s v\_{rp} + c v\_{rq}\\\\
\end{align}

### Enough with the talking! LETS COMPUTE STUFF


```julia
# First, Lets make our nice, helpful functions

## A function to look at the convergence
function convergence(A::Array)
    num=0.0
    l=size(A)[1]
    for ii in 1:(l-1)
        for jj in (ii+1):l ## just looking at the lower triangle
            num+=A[ii,jj]^2
            #println(ii,&#39; &#39;,jj,&#39; &#39;,num,&#39; &#39;,A[ii,jj])
        end
    end
    return num
end
```


This makes a matrix easier to look at than when its filled
with 1.043848974e-12 everywhere

```julia
function roundmatrix(A::Array,rtol::Real)
    Ap=copy(A)
    for ii in 1:length(A)
        if abs(Ap[ii])&amp;lt;rtol
            Ap[ii]=0
        end
    end
    return Ap;
end
```




```julia
## Here we create a random symmetric matrix
function makeA(n::Int)
    A=randn(n,n);
    for ii in 1:n
        A[ii,1:ii]=transpose(A[1:ii,ii])
    end
    V=eye(n) #initializing the orthogonal transformation
    return A,copy(A),V
end
## One A returned will be stored to compare initial and final
```

Now on to the Rotations!

 We don&#39;t always want to compute the eigenvectors, so those are in the optional entries slot.
Both tell the function to compute the vectors with `computeV=true`
and input the `V=V` after the semicolon.


```julia
function Rotate(A::Array,p::Int,q::Int; computeV=false, V::Array=eye(1))
    θ=(A[q,q]-A[p,p])/(2*A[p,q]);
    t=sign(θ)/(abs(θ)+sqrt(θ^2+1));

    c=1/sqrt(t^2+1)
    s=t*c
    τ=s/(1+c)

    l=size(A)[1]
    Ap=copy(A[:,p])
    Aq=copy(A[:,q])
    for r in 1:l
        A[r,p]=Ap[r]-s*(Aq[r]+τ*Ap[r])
        A[r,q]=Aq[r]+s*(Ap[r]-τ*Aq[r])

        A[p,r]=A[r,p]
        A[q,r]=A[r,q]
    end
    A[p,q]=0
    A[q,p]=0
    A[p,p]=Ap[p]-t*Aq[p]
    A[q,q]=Aq[q]+t*Aq[p]

    if computeV==true
        Vp=copy(V[:,p])
        Vq=copy(V[:,q])
        for r in 1:l
            V[r,p]=c*Vp[r]-s*Vq[r]
            V[r,q]=s*Vp[r]+c*Vq[r]
        end
        return A,V
    else
        return A;
    end
end
```

This function performs one sweep

```julia

function Sweep(A;compV=false,V=eye(1))
    n=size(A)[1]
    for ii in 2:n
        for jj in 1:(ii-1) ## Just over one triangle
            if compV==false
                A=Rotate(A,ii,jj)
            else
                A,V=Rotate(A,ii,jj;computeV=true,V=V);
            end
        end
    end

    if compV==false
        return A
    else
        return A,V
    end
end
```



Just creating some size of matrix

```julia
A,A0,V=makeA(5);
```


```julia
## keep evaluating for a couple iterations
## watch how it changes
A,V=Sweep(A;compV=true,V=V);
roundmatrix(A,1e-10),A,V,convergence(A)
```


This output is after several sweeps

        (
        5x5 Array{Float64,2}:
         -1.59942  0.0       0.0       0.0      0.0
          0.0      1.03678   0.0       0.0      0.0
          0.0      0.0      -0.823094  0.0      0.0
          0.0      0.0       0.0       3.09433  0.0
          0.0      0.0       0.0       0.0      1.3409,

        5x5 Array{Float64,2}:
         -1.59942      5.1314e-30    2.32594e-36  -9.54088e-49  -1.22782e-53
          5.1314e-30   1.03678       2.65014e-38   9.13791e-56   6.64996e-67
          2.32594e-36  2.65014e-38  -0.823094     -9.56652e-61   2.08002e-92
         -9.54088e-49  9.13791e-56  -9.56652e-61   3.09433       0.0
         -1.22782e-53  6.64996e-67   2.08002e-92   0.0           1.3409     ,

        5x5 Array{Float64,2}:
          0.0537334   0.0599494  -0.735228  0.139      0.658511
          0.310018    0.612957   -0.14049   0.611348  -0.367001
          0.759653   -0.475834    0.264118  0.282571   0.216575
         -0.480405   -0.546544   -0.132383  0.644217  -0.194831
         -0.305189    0.30913     0.593648  0.33477    0.588905,

        2.6331310238375346e-59)



Compare the Optimized LAPLACK routine to your results

```julia
eig(A0)
```

          ([-1.599424470672961,-0.8230937166650976,1.0367806031602211,
          1.3408963512476402,3.0943321944116593],
          5x5 Array{Float64,2}:
           -0.0537334   0.735228   0.0599494  -0.658511  -0.139
           -0.310018    0.14049    0.612957    0.367001  -0.611348
           -0.759653   -0.264118  -0.475834   -0.216575  -0.282571
            0.480405    0.132383  -0.546544    0.194831  -0.644217
            0.305189   -0.593648   0.30913    -0.588905  -0.33477 )




```julia
## A good check to make sure V is an orthonomal transformation
roundmatrix(V*A*transpose(V)-A0,1e-12)
```

          5x5 Array{Float64,2}:
           0.0  0.0  0.0  0.0  0.0
           0.0  0.0  0.0  0.0  0.0
           0.0  0.0  0.0  0.0  0.0
           0.0  0.0  0.0  0.0  0.0
           0.0  0.0  0.0  0.0  0.0


How long does it take to make a Sweep?
How much memory will the computation take?
This is dependent on how large the matrix is, and determines whether or not we
want to use this algorithm.

```julia

A,A0,V=makeA(10);
@time Sweep(A);
A,A0,V=makeA(20);
@time Sweep(A);
A,A0,V=makeA(100);
@time Sweep(A);
```

      0.000028 seconds (320 allocations: 30.469 KB)
      0.000099 seconds (1.33 k allocations: 187.266 KB)
      0.007413 seconds (34.66 k allocations: 17.448 MB, 14.20% gc time)


In addition to time per sweep, we need to know how many sweeps we need to run. So again we run it on a 10x10, 20x20, and 100x100. The efficiency of the algorithm would get a lot worse if we have to sweep the 100x100 a bunch of times.


```julia
A10,Ap10,V=makeA(10);
A20,Ap20,V=makeA(20);
A100,Ap100,V=makeA(100);
nsweep=collect(1:7);
conv10=zeros(7)
conv20=zeros(7)
conv100=zeros(7)
for i in nsweep
    A10=Sweep(A10)
    A20=Sweep(A20)
    A100=Sweep(A100)
    conv10[i]=convergence(A10)
    conv20[i]=convergence(A20)
    conv100[i]=convergence(A100)
end

[nsweep conv10/10 conv20/20 conv100/100]
```




    7x4 Array{Float64,2}:
     1.0  1.10944       2.43759      14.6644
     2.0  0.105628      0.312076      2.87182
     3.0  0.000265288   0.017073      0.498082
     4.0  6.64324e-9    0.000119472   0.0390564
     5.0  4.05463e-18   3.56679e-11   0.00133833
     6.0  3.17274e-42   1.96318e-23   6.07661e-7
     7.0  6.76289e-110  4.07871e-49   3.98102e-13



Well, so we&#39;ve seen how to do one form of exact diagonalization that works, but doesn&#39;t scale very well up to 100x100 matrices.  So stay tuned for the Householder method, hopefully coming up soon.

Until then, happy computing :)
&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Jan 2015 00:00:00 +0900</pubDate>
        <link>/M4/numerics/Jacobi-Transformation.html</link>
        <guid isPermaLink="true">/M4/numerics/Jacobi-Transformation.html</guid>
        
        <category>Exact Diagonalization</category>
        
        
        <category>numerics</category>
        
      </item>
    
      <item>
        <title>Atomic Orbitals Pt. 2</title>
        <description>&lt;p&gt;&lt;b&gt;Prerequiresites:&lt;/b&gt; Quantum Mechanics course&lt;/p&gt;

&lt;p&gt;If you haven’t read it already, checkout &lt;a href=&quot;/M4/undergrad/Atomic-Orbitals.html&quot;&gt;Atomic Orbitals Pt. 1&lt;/a&gt;.  Today we try and make some prettier pictures.  GLVisualize is a quite beautiful package, but not entirely the easiest to use at this point with some not so consistent documentation.&lt;/p&gt;

&lt;p&gt;To add&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
Pkg.add(&quot;GLVisualize&quot;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and test with&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
Pkg.test(&quot;GLVisualize&quot;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;But other steps may be necessary to get the package working.  On a Mac, I needed to install the Homebrew.jl package.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
#Pkg.update();
#Pkg.add(&quot;GSL&quot;);
using GSL;
using GLVisualize;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```julia
a0=1; #for convenience, or 5.2917721092(17)×10−11 m&lt;/p&gt;

&lt;h1 id=&quot;the-unitless-radial-coordinate&quot;&gt;The unitless radial coordinate&lt;/h1&gt;
&lt;p&gt;ρ(r,n)=2r/(n*a0);&lt;/p&gt;

&lt;h1 id=&quot;the--dependence&quot;&gt;The θ dependence&lt;/h1&gt;
&lt;p&gt;function Pmlh(m::Int,l::Int,θ::Real)
    return (-1.0)^m *sf_legendre_Plm(l,m,cos(θ));
end&lt;/p&gt;

&lt;h1 id=&quot;the--and--dependence&quot;&gt;The θ and ϕ dependence&lt;/h1&gt;
&lt;p&gt;function Yml(m::Int,l::Int,θ::Real,ϕ::Real)
    return  (-1.0)^m&lt;em&gt;sf_legendre_Plm(l,abs(m),cos(θ))&lt;/em&gt;e^(im&lt;em&gt;m&lt;/em&gt;ϕ)
end&lt;/p&gt;

&lt;h1 id=&quot;the-radial-dependence&quot;&gt;The Radial dependence&lt;/h1&gt;
&lt;p&gt;function R(n::Int,l::Int,ρ::Real)
    if isapprox(ρ,0)
        ρ=.001
    end
     return sf_laguerre_n(n-l-1,2&lt;em&gt;l+1,ρ)&lt;/em&gt;e^(-ρ/2)*ρ^l
end&lt;/p&gt;

&lt;h1 id=&quot;a-normalization-this-is-dependent-on-the-choice-of-polynomial-representation&quot;&gt;A normalization: This is dependent on the choice of polynomial representation&lt;/h1&gt;
&lt;p&gt;function norm(n::Int,l::Int)
    return sqrt((2/n)^3 * factorial(n-l-1)/(2n*factorial(n+l)))
end&lt;/p&gt;

&lt;h1 id=&quot;generates-an-orbital-funtion-of-r-for-a-specificied-nlm&quot;&gt;Generates an Orbital Funtion of (r,θ,ϕ) for a specificied n,l,m.&lt;/h1&gt;
&lt;p&gt;function Orbital(n::Int,l::Int,m::Int)
    if (l&amp;gt;n)    # we make sure l and m are within proper bounds
        throw(DomainError())
    end
    if abs(m)&amp;gt;l
       throw(DomainError())
    end
    psi(ρ,θ,ϕ)=norm(n, l)&lt;em&gt;R(n,l,ρ)&lt;/em&gt;Yml(m,l,θ,ϕ);
    return psi
end&lt;/p&gt;

&lt;h1 id=&quot;we-will-calculate-is-spherical-coordinates-but-plot-in-cartesian-so-we-need-this-array-conversion&quot;&gt;We will calculate is spherical coordinates, but plot in cartesian, so we need this array conversion&lt;/h1&gt;
&lt;p&gt;function SphtoCart(r::Array,θ::Array,ϕ::Array)
    x=r.&lt;em&gt;sin(θ).&lt;/em&gt;cos(ϕ);
    y=r.&lt;em&gt;sin(θ).&lt;/em&gt;sin(ϕ);
    z=r.*cos(θ);
    return x,y,z;
end&lt;/p&gt;

&lt;p&gt;function CarttoSph(x::Array,y::Array,z::Array)
    r=sqrt(x.^2+y.^2+z.^2);
    θ=acos(z./r);
    ϕ=atan(y./x);
    return r,θ,ϕ;
end&lt;/p&gt;

&lt;p&gt;“Defined Helper Functions”
```&lt;/p&gt;

&lt;p&gt;Here create a square cube, and convert those positions over to spherical coordinates.&lt;/p&gt;

&lt;p&gt;```julia
range=-10:.5:10
x=collect(range);
y=collect(range);
z=collect(range);
N=length(x);
xa=repeat(x,outer=[1,N,N]);
ya=repeat(transpose(y),outer=[N,1,N]);
za=repeat(reshape(z,1,1,N),outer=[N,N,1]);
println(“created x,y,z”)&lt;/p&gt;

&lt;p&gt;r,θ, ϕ=CarttoSph(xa,ya,za);
println(“created r,θ,ϕ”)
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
Ψ=Orbital(3,2,-1)
Ψp=Orbital(3,1,0)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
Ψv = zeros(Float32,N,N,N);
ϕv = zeros(Float32,N,N,N);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```julia
for nn in 1:N
    for jj in 1:N
        for kk in 1:N
            val=Ψ(ρ(r[nn,jj,kk],2),θ[nn,jj,kk],ϕ[nn,jj,kk]);
            #val+=Ψp(ρ(r[nn,jj,kk],2),θ[nn,jj,kk],ϕ[nn,jj,kk]);
            Ψv[nn,jj,kk]=convert(Float32,abs(val));
            ϕv[nn,jj,kk]=convert(Float32,angle(val));
        end
    end
end&lt;/p&gt;

&lt;p&gt;mid=round(Int,(N-1)/2+1);
Ψv[mid,mid,:]=Ψv[mid+1,mid+1,:]; # the one at the center diverges
Ψv=(Ψv-minimum(Ψv))/(maximum(Ψv)-minimum(Ψv) );
```&lt;/p&gt;

&lt;p&gt;```julia
w,r = glscreen()&lt;/p&gt;

&lt;p&gt;robj=visualize(Ψv)&lt;/p&gt;

&lt;h1 id=&quot;choose-this-one-for-surfaces-of-constant-of-intensity&quot;&gt;choose this one for surfaces of constant of intensity&lt;/h1&gt;
&lt;p&gt;view(visualize(robj[:intensities],:iso))&lt;/p&gt;

&lt;h1 id=&quot;choose-this-for-a-block-of-3d-density&quot;&gt;choose this for a block of 3D density&lt;/h1&gt;
&lt;p&gt;#view(visualize(Ψv))
r()
```&lt;/p&gt;

&lt;h2 id=&quot;p-orbital&quot;&gt;2p Orbital&lt;/h2&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals2/2p_spaceb.png&quot; alt=&quot;2p&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;2p Orbital block showing the density of the wavefunction.&lt;/p&gt;
    
&lt;/div&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals2/2p_surface.png&quot; alt=&quot;2p&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;2p Orbital shown via isosurface.&lt;/p&gt;
    
&lt;/div&gt;

&lt;h2 id=&quot;d-orbitals&quot;&gt;3d orbitals&lt;/h2&gt;
&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals2/3d0_surface.png&quot; alt=&quot;3d0&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;3dz2 Orbital shown via isosurface. This corresponds to n=3, l=2, m=0.&lt;/p&gt;
    
&lt;/div&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals2/3d-1_surface.png&quot; alt=&quot;3dm1&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;A 3d Orbital shown via isosurface. This corresponds to n=3, l=2, m=neg 1. This is not one of the cannonical images, but instead an m shape.&lt;/p&gt;
    
&lt;/div&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals2/3d2-2_spaceb.png&quot; alt=&quot;3dxy&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;3dxy (x2-y2) orbital shown in density.  This is the sum of an m=neg 2 and m=2 state, for n=3,l=2. &lt;/p&gt;
    
&lt;/div&gt;

&lt;h2 id=&quot;p&quot;&gt;3p&lt;/h2&gt;
&lt;p&gt;In order to get this 3p surface image to come out correctly, I used the square root of the values instead in order to be able to see the much fainter outer lobe.&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals2/3p_surface.png&quot; alt=&quot;3p&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;3p surface plot.&lt;/p&gt;
    
&lt;/div&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals2/3p_spaceb.png&quot; alt=&quot;3p&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;3p space plot.&lt;/p&gt;
    
&lt;/div&gt;

</description>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0900</pubDate>
        <link>/M4/prerequisites/Atomic-Orbitals2.html</link>
        <guid isPermaLink="true">/M4/prerequisites/Atomic-Orbitals2.html</guid>
        
        <category>Quantum</category>
        
        
        <category>prerequisites</category>
        
      </item>
    
      <item>
        <title>Atomic Orbitals</title>
        <description>&lt;p&gt;&lt;b&gt;Prerequiresites:&lt;/b&gt; Quantum Mechanics course&lt;/p&gt;

&lt;p&gt;Electrons around a nucleus.  Do they look like little well behaved planets orbiting a sun?&lt;/p&gt;

&lt;p&gt;NOPE!&lt;/p&gt;

&lt;p&gt;We get spread out blobs in special little patterns called orbitals.  Here, we will look at their shapes and properties a bit.  Today we will look at graphs in 1D and 2D, but the next post, &lt;a href=&quot;/M4/undergrad/Atomic-Orbitals2.html&quot;&gt;Atomic Orbitals Pt. 2&lt;/a&gt;, uses a fancy, but slightly unstable plotting package, GLVisualize to generate some 3D plots.&lt;/p&gt;

&lt;p&gt;The Hamiltonian for our problem is:&lt;/p&gt;

&lt;p&gt;\begin{equation}
{\cal H}\Psi(x) =\left[ -\frac{\hbar}{2 m} \nabla^2 - \frac{Z e^2}{4 \pi \epsilon_0 r}\right]\Psi(x) = E \Psi(x)
\end{equation}
with
\begin{equation}
\nabla^2= \frac{1}{r^2}\frac{\partial}{\partial r} \left(
r^2 \frac{\partial}{\partial r}
\right)+
\frac{1}{r^2 \sin \theta} \frac{\partial}{\partial \theta} \left(
\sin \theta \frac{\partial}{\partial \theta}
\right)+
\frac{1}{r^2 \sin^2 \theta} \frac{\partial^2}{\partial \phi^2}
\end{equation}&lt;/p&gt;

&lt;p&gt;To solve this problem, we begin by guessing a solution with seperated Radial and Angular variables,
\begin{equation}
\Psi(x) = R(r) \Theta ( \theta,\phi)
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation}
\frac{E r^2 R(r)}{2r R^{\prime}(r) + r^2 R^{\prime \prime}(r)}=
\frac{\left( \frac{1}{\sin \theta} \frac{\partial}{\partial \theta} \left(
\sin \theta \frac{\partial \Theta(\theta,\phi)}{\partial \theta}
\right)+
\frac{1}{\sin^2 \theta} \frac{\partial^2 \Theta(\theta,\phi)}{\partial \phi^2}\right)      }{\Theta( \theta, \phi)}
=C
\end{equation}&lt;/p&gt;

&lt;p&gt;Instead of going into the precise mechanisms of solving those two seperate equations here, trust for now that they follow standard special functions, the associated Legendre Polynomial and the generalized Laguerre Polynomial.  Try a standard Quantum Mechanics textbook for more information about this.&lt;/p&gt;

&lt;p&gt;\begin{equation}
        Y\^m_l(θ,ϕ) = (-1)\^m e\^{i m \phi} P\^m_l (\cos(θ))
\end{equation}
where $P^m_l (\cos (\theta))$ is the associated Legendre Polynomial.&lt;/p&gt;

&lt;p&gt;\begin{equation}
    R\^{n,l} (\rho) = \rho\^l e\^{-\rho/2} L\^{2 l+1}_{n-l-1} (\rho)
\end{equation}
where $L\^{2 l+1}_{n-l-1}(\rho)$ is the generalized Laguerre polynomial.&lt;/p&gt;

&lt;p&gt;\begin{equation}
    \rho=\frac{2r}{n a_0}
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation}
    N=\sqrt{\left(\frac{2}{n}\right)^3 \frac{(n-l-1)}{2n(n+l)!}}
\end{equation}&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
#Pkg.update();
#Pkg.add(&quot;GSL&quot;);
#Pkg.add(&quot;PyPlot&quot;);
using GSL;    #GSL holds the special functions
using PyPlot;
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;cell-to-evaluate&quot;&gt;Cell to Evaluate&lt;/h4&gt;
&lt;p&gt;What’s below is a bunch of definitions that makes our calculations easier later on.  Here I utalize the Gnu scientific library, GSL imported above, to calculate the special functions.&lt;/p&gt;

&lt;div class=&quot;progtip&quot;&gt;
&lt;h3 color=&quot;black&quot;&gt; Programming Tip!&lt;/h3&gt;
&lt;p&gt;Even though its not necessary, specifying the type of inputs to a function through &lt;code&gt;m::Int&lt;/code&gt; helps prevent improper inputs and allows the compiler to perform additional optimizations.  Julia also implements &lt;i&gt;Abstract Types&lt;/i&gt;, so we don&#39;t have to specify the exact type of Int.  Real allows and numerical, non-complex type.&lt;/p&gt;
&lt;p&gt;
Type greek characters in Jupyter notebooks via LaTeX syntax.  ex: \alpha+tab&lt;/p&gt;
&lt;p&gt;
The function &lt;code&gt;Orbital&lt;/code&gt; throws &lt;code&gt;DomainError()&lt;/code&gt; when &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;m&lt;/code&gt; do not obey their bounds.  Julia supports a wide variety of easy to use error messages.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;```julia
a0=1; #for convenience, or 5.2917721092(17)×10−11 m&lt;/p&gt;

&lt;h1 id=&quot;the-unitless-radial-coordinate&quot;&gt;The unitless radial coordinate&lt;/h1&gt;
&lt;p&gt;ρ(r,n)=2r/(n*a0);&lt;/p&gt;

&lt;h1 id=&quot;the--dependence&quot;&gt;The θ dependence&lt;/h1&gt;
&lt;p&gt;function Pmlh(m::Int,l::Int,θ::Real)
    return (-1.0)^m *sf_legendre_Plm(l,m,cos(θ));
end&lt;/p&gt;

&lt;h1 id=&quot;the--and--dependence&quot;&gt;The θ and ϕ dependence&lt;/h1&gt;
&lt;p&gt;function Yml(m::Int,l::Int,θ::Real,ϕ::Real)
    return  (-1.0)^m&lt;em&gt;sf_legendre_Plm(l,m,cos(θ))&lt;/em&gt;e^(im&lt;em&gt;m&lt;/em&gt;ϕ)
end&lt;/p&gt;

&lt;h1 id=&quot;the-radial-dependence&quot;&gt;The Radial dependence&lt;/h1&gt;
&lt;p&gt;function R(n::Int,l::Int,ρ::Real)
    if isapprox(ρ,0)
        ρ=.01
    end
     return sf_laguerre_n(n-l-1,2&lt;em&gt;l+1,ρ)&lt;/em&gt;e^(-ρ/2)*ρ^l
end&lt;/p&gt;

&lt;h1 id=&quot;a-normalization-this-is-dependent-on-the-choice-of-polynomial-representation&quot;&gt;A normalization: This is dependent on the choice of polynomial representation&lt;/h1&gt;
&lt;p&gt;function norm(n::Int,l::Int)
    return sqrt((2/n)^3 * factorial(n-l-1)/(2n*factorial(n+l)))
end&lt;/p&gt;

&lt;h1 id=&quot;generates-an-orbital-funtion-of-r-for-a-specificied-nlm&quot;&gt;Generates an Orbital Funtion of (r,θ,ϕ) for a specificied n,l,m.&lt;/h1&gt;
&lt;p&gt;function Orbital(n::Int,l::Int,m::Int)
    if l&amp;gt;n    # we make sure l and m are within proper bounds
        throw(DomainError())
    end
    if abs(m)&amp;gt;l
        throw(DomainError())
    end
    psi(ρ,θ,ϕ)=norm(n, l)&lt;em&gt;R(n,l,ρ)&lt;/em&gt;Yml(m,l,θ,ϕ);
    return psi
end&lt;/p&gt;

&lt;h1 id=&quot;we-will-calculate-is-spherical-coordinates-but-plot-in-cartesian-so-we-need-this-array-conversion&quot;&gt;We will calculate is spherical coordinates, but plot in cartesian, so we need this array conversion&lt;/h1&gt;
&lt;p&gt;function SphtoCart(r::Array,θ::Array,ϕ::Array)
    x=r.&lt;em&gt;sin(θ).&lt;/em&gt;cos(ϕ);
    y=r.&lt;em&gt;sin(θ).&lt;/em&gt;sin(ϕ);
    z=r.*cos(θ);
    return x,y,z;
end&lt;/p&gt;

&lt;p&gt;function CarttoSph(x::Array,y::Array,z::Array)
    r=sqrt(x.^2+y.^2+z.^2);
    θ=acos(z./r);
    ϕ=atan(y./x);
    return r,θ,ϕ;
end&lt;/p&gt;

&lt;p&gt;“Defined Helper Functions”
```&lt;/p&gt;

&lt;h4 id=&quot;parameters&quot;&gt;Parameters&lt;/h4&gt;
&lt;p&gt;Grid parameters:
You might need to change &lt;code&gt;rmax&lt;/code&gt; to be able to view higher n orbitals.&lt;/p&gt;

&lt;p&gt;Remember that
\begin{equation}
0&amp;lt;n \;\;\;\;\; \;\;\;\; 0 \leq l &amp;lt; n \;\;\;\;\; \;\;\;\; -l \leq m \leq l
\;\;\;\;\; \;\;\;\; n,l,m \in {\cal Z}
\end{equation}&lt;/p&gt;

&lt;p&gt;```julia
# Grid Parameters
rmin=.05
rmax=10
Nr=100 #Sampling frequency
Nθ=100
Nϕ=100&lt;/p&gt;

&lt;h1 id=&quot;choose-which-orbital-to-look-at&quot;&gt;Choose which Orbital to look at&lt;/h1&gt;
&lt;p&gt;n=3;
l=1;
m=0;
“Defined parameters”
```&lt;/p&gt;

&lt;p&gt;```julia
#Linear Array of spherical coordinates
r=collect(linspace(rmin,rmax,Nr));
ϕ=collect(linspace(0,2π,Nθ));
θ=collect(linspace(0,π,Nϕ));
#3D arrays of spherical coordinates, in order r,θ,ϕ
ra=repeat(r,outer=[1,Nθ,Nϕ]);
θa=repeat(transpose(θ),outer=[Nr,1,Nϕ]);
ϕa=repeat(reshape(ϕ,1,1,Nϕ),outer=[Nr,Nθ,1]);&lt;/p&gt;

&lt;p&gt;x,y,z=SphtoCart(ra,θa,ϕa);
```&lt;/p&gt;

&lt;p&gt;Though I could create a wrapped up function with &lt;code&gt;Orbital(n,l,m)&lt;/code&gt; and evaluate that at each point, the below evaluation takes advantage of the seperatability of the solution with respect to spherical dimensions.  The special functions, especially for higher modes, take time to calculate, and the fewer calls to GSL, the faster the code will run.  Therefore, this implementation copies over radial and angular responses.&lt;/p&gt;

&lt;p&gt;```julia
Ψ=zeros(Float64,Nr,Nϕ,Nθ)
θd=Int64(round(Nθ/2))  ## gives approximately the equator.  Will be useful later&lt;/p&gt;

&lt;p&gt;p1=Pmlh(m,l,θ[1]);
p2=exp(im&lt;em&gt;m&lt;/em&gt;ϕ[1]);
for i in 1:Nr
    Ψ[i,1,1]=norm(n,l)&lt;em&gt;R(n,l,ρ(r[i],n))&lt;/em&gt;p1*p2;
end&lt;/p&gt;

&lt;p&gt;for j in 1:Nθ
    Ψ[:,j,1]=Ψ[:,1,1]*Pmlh(m,l,θ[j])/p1;
end&lt;/p&gt;

&lt;p&gt;for k in 1:Nϕ
    Ψ[:,:,k]=Ψ[:,:,1]&lt;em&gt;exp(im&lt;/em&gt;m*ϕ[k])/p2;
end
```&lt;/p&gt;

&lt;p&gt;```julia
pygui(false)
xlabel(“θ”)
ylabel(“Ψ”)
title(“Wavefunction for n= $n ,l= $l ,m= $m “)&lt;/p&gt;

&lt;p&gt;annotate(“l= $l Angular Node”,
xy=[π/2;0],
xytext=[π/2+.1;.02],
xycoords=”data”,
arrowprops=Dict(“facecolor”=&amp;gt;”black”))&lt;/p&gt;

&lt;p&gt;plot(θ,zeros(θ))
plot(θ,reshape(Ψ[50,:,1],100)) #reshape makes Ψ 1D
```&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals/angular1di.png&quot; alt=&quot;2p Angle Slice&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;A slice along the θ plane showing an angular node for the 2p orbital.&lt;/p&gt;
    
&lt;/div&gt;

&lt;p&gt;```julia
pygui(false)
xlabel(“r”)
ylabel(“Ψ”)
title(“Wavefunction for n= $n ,l= $l ,m= $m “)&lt;/p&gt;

&lt;p&gt;plot(r,zeros(r))
plot(r,reshape(Ψ[:,50,1],100)) #reshape makes Ψ 1D
```
&lt;!-- _includes/image.html --&gt;
&amp;lt;div class=&quot;image-wrapper&quot; &amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;img src=&quot;/M4/Images/Orbitals/radial1di.png&quot; alt=&quot;3p Radial Slice&quot;/&amp;gt;


    &amp;lt;p class=&quot;image-caption&quot;&amp;gt;A slice along the radial plane showing a radial node in the 3p orbital.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
#rap=squeeze(ra[:,:,50],3)
#θap=squeeze(θa[:,:,50],3)
#ϕap=squeeze(ϕa[:,:,50],3)
#Ψp=squeeze(Ψ[:,:,50],3)
rap=ra[:,:,50]
θap=θa[:,:,50]
ϕap=ϕa[:,:,50]
Ψp=Ψ[:,:,50]
xp,yp,zp=SphtoCart(rap,θap,ϕap);
pygui(false)
xlabel(&quot;x&quot;)
ylabel(&quot;z&quot;)
title(&quot;ϕ-slice of Ψ for n=$n, l=$l, m=$m&quot;)
pcolor(xp[:,:],zp[:,:],Ψp[:,:],cmap=&quot;coolwarm&quot;)
colorbar()
&lt;/code&gt;&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals/angular2di.png&quot; alt=&quot;3p in 2d&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Slice of a 3p orbital in the x and z plane.&lt;/p&gt;
    
&lt;/div&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/Orbitals/angular2d2i.png&quot; alt=&quot;3dz2 in 2d&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Slice of a 3dz2 orbital in the x and z plane.&lt;/p&gt;
    
&lt;/div&gt;

&lt;p&gt;Don’t forget to checkout &lt;a href=&quot;/M4/undergrad/Atomic-Orbitals2.html&quot;&gt;Atomic Orbitals Pt. 2&lt;/a&gt;!&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Jan 2015 00:00:00 +0900</pubDate>
        <link>/M4/prerequisites/Atomic-Orbitals.html</link>
        <guid isPermaLink="true">/M4/prerequisites/Atomic-Orbitals.html</guid>
        
        <category>Quantum</category>
        
        
        <category>prerequisites</category>
        
      </item>
    
      <item>
        <title>Quantum Harmonic Osscilator</title>
        <description>&lt;p&gt;&lt;b&gt;Prerequiresites:&lt;/b&gt; Quantum Mechanics course&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Slinkies&lt;/b&gt;. They started out as toys.  I still have one to play with on my desk.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Rubber bands&lt;/b&gt; What was once something useful, is now a wonderful projectile weapon.&lt;/p&gt;

&lt;p&gt;&lt;b&gt; Swings&lt;/b&gt; I still love them, but people seem to not make them in adult sizes for some reason.&lt;/p&gt;

&lt;p&gt;A person’s perception of these objects start to change as they enter their first physics class.  Even in that beginning classical mechanics, the problems are filled with harmonic osscilators, like slinkies, rubber bands, or swings, which exert a force proportional to their displacement
\begin{equation}
F=-kx
\end{equation}
and therefore a quadratic potential
\begin{equation}
V(x)=k x^2
\end{equation}&lt;/p&gt;

&lt;p&gt;This is all extremely fun and useful in the classical regime, but we add Quantum Mechanics to the mix, and LOW AND BEHOLD! we have one of the few exactly solvable models in Quantum Mechanics. Moreso, this solution demonstrates some extremely important properties of quantum mechanical systems.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;The Hamiltonian&lt;/b&gt;
\begin{equation}
    {\cal H}= \frac{p^2}{2 m} + \frac{1}{2} m \omega ^2 x^2
\end{equation}&lt;/p&gt;

&lt;p&gt;&lt;b&gt; The Solution&lt;/b&gt;
\begin{equation}
    \Psi (x) = \frac{1}{\sqrt{2^n n!}} \left(\frac{m \omega}{\hbar \pi}\right)^{1/4} \mathrm{e}^{-m \omega x^2/2 \hbar}  H_n \left( \sqrt{\frac{m \omega}{\hbar}} x \right)
\end{equation}
Today, I just intend to present the form of the solution, calculate this equation numerically, and visualize the results.  If you wish to know how the equation is derived, you can find a standard quantum mechanics textbook, or stay tuned till I manage to write it up.&lt;/p&gt;

&lt;h3 id=&quot;physicists-hermite-polynomials&quot;&gt;Physicists’ Hermite Polynomials&lt;/h3&gt;
&lt;p&gt;Note: These are not the same as the “probabilists’ Hermite Polynomial”.  The two functions differ by scaling factors.&lt;/p&gt;

&lt;p&gt;Physicists’ Hermite polynomials are defined as eigenfunctions for the differential equation
\begin{equation}
u^{\prime \prime}-2xu^{\prime} = -2 \lambda u
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation}
H_n(x) = (-1)^n \mathrm{e}^{x^2} \frac{\mathrm{d}^n}{\mathrm{d}x^n}
\left( e^{-x^2} \right)
\end{equation}&lt;/p&gt;

&lt;p&gt;I leave it as an exercise to the reader to:&lt;/p&gt;

&lt;p&gt;demonstrate othogonality with respect to the measure , ie&lt;/p&gt;

&lt;p&gt;\begin{equation}
 \int\limits_b\^a H_{n}
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation} \int_{-\infty}\^{\infty} H_m(x) H_n(x) e\^{-x\^2} \mathrm{d}x = \sqrt{\pi} 2\^n n! \delta_{mn} \end{equation}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; demonstrate completeness.  This means we can describe every function by a linear combination of Hermite polynomials, provided it is suitably well behaved.


Though a formula exists or calculating a function at n directly, the most efficient method at low n for calculating polynomials relies on recurrence relationships.  These recurrence relationships will also be quite handy if you ever need to show orthogonality, or expectation values.

### Recurrence Relations

\begin{equation}
H\_{n+1}(x) = 2xH\_n(x) - H\^{\prime}\_n(x)
\end{equation}
\begin{equation}
H\^{\prime}\_n(x) = 2n H\_{n-1}(x)
\end{equation}
\begin{equation}
H\_{n+1}(x) = 2x H\_n(x) - 2n H\_{n-1}(x)
\end{equation}


```julia
#Pkg.update();
#Pkg.add(&quot;PyPlot&quot;);
#Pkg.update()
#Pkg.add(&quot;Roots&quot;)
using Roots;
using PyPlot;
```

&lt;div class=&quot;progtip&quot;&gt;
&lt;h3 color=&quot;black&quot;&gt; Programming Tip!&lt;/h3&gt;
Since Hermite polynomials are generated recursively, I wanted to generate and save all the functions up to a designated value at once.  In order to do so, I created an array, whose values are anonymous functions.
&lt;/div&gt;

```julia
function GenerateHermite(n)
    Hermite=Function[]

    push!(Hermite,x-&amp;gt;1);
    push!(Hermite,x-&amp;gt;2*x);

    for ni in 3:n
        push!(Hermite,x-&amp;gt;2.*x.*Hermite[ni-1](x).-2.*n.*Hermite[ni-2](x))
    end
    return Hermite
end
```



So lets generate some Hermite polynomials and look at them.
&lt;b&gt; Make sure you don&#39;t call a Hermite you haven&#39;t generated yet!


```julia
Hermite=GenerateHermite(5)
```
&lt;div class=&quot;progtip&quot;&gt;
&lt;h3 color=&quot;black&quot;&gt;Programming Tip!&lt;/h3&gt;
Since the Hermite polynomials, and the wavefunctions after them, are composed on anonymous functions, we need to use &lt;code&gt;map(f,x)&lt;/code&gt; in order to map the function &lt;code&gt;f&lt;/code&gt; onto the array &lt;code&gt;x&lt;/code&gt;.  Otherwise our polynomials only work on single values.
&lt;/div&gt;

```julia
x=collect(-2:.01:2);
for j in 1:5
    plot(x,map(Hermite[j],x),label=&quot;H_$j (x)&quot;)
end
legend()
ylim(-50,50)
```


&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/QHO/hermitesi.png&quot; alt=&quot;Hermite Polynomials&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;First few Hermite Polynomials&lt;/p&gt;
    
&lt;/div&gt;



```julia
# Lets make our life easy and set all units to 1
m=1
ω=1
ħ=1

#Finally, we define Ψ
Ψ(n,x)=1/sqrt(factorial(n)*2^n)*(m*ω/(ħ*π))^(1/4)*exp(-m*ω*x^2/(2*ħ))*Hermite[n](sqrt(m*ω/ħ)*x)
```



### Finding Zeros
The eigenvalue maps to the number of zeros in the wavefunction.  Below, I use Julia&#39;s roots package to indentify roots on the interval from -3 to 3.


```julia
zeds=Array{Array{Float64}}(1)
zeds[1]=[] #ground state has no zeros
for j in 2:4
    push!(zeds,fzeros(y-&amp;gt;Ψ(j,y),-3,3))
end
```


```julia
# AHHHHH! So Much code!
# Don&#39;t worry; it&#39;s all just plotting
x=collect(-3:.01:3)  #Set some good axes

for j in 1:4    #how many do you want to view?
    plot(x,map(y-&amp;gt;Ψ(j,y),x)+j-1,label=&quot;| $j &amp;gt;&quot;)
    plot(x,(j-1)*ones(x),color=&quot;black&quot;)
    scatter(zeds[j],(j-1)*ones(zeds[j]),marker=&quot;o&quot;,s=40)
end
plot(x,.5*m*ω^2*x.^2,linestyle=&quot;--&quot;,label=&quot;Potential&quot;)

scatter([],[],marker=&quot;o&quot;,s=40,label=&quot;Zeros&quot;)
xlabel(&quot;x&quot;)
ylabel(&quot;Ψ+n&quot;)
title(&quot;Eigenstates of a Harmonic Osscilator&quot;)
legend()
xlim(-3,3);
ylim(-.5,4.5);
```


## Example Result

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/QHO/eigenstatesi.png&quot; alt=&quot;Eigenstates&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Eigenstates of the Quantum Harmonic Osscillator&lt;/p&gt;
    
&lt;/div&gt;


## More to come
This barely scratched the surface into the richness that can be seen in the quantum harmonic osscilator.  Here, just we developed a way for calculating the functions, and visualized the results.  Stay tuned to hear here about ground state energy, ladder operators, and atomic trapping.
&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
        <pubDate>Sat, 03 Jan 2015 00:00:00 +0900</pubDate>
        <link>/M4/prerequisites/QHO.html</link>
        <guid isPermaLink="true">/M4/prerequisites/QHO.html</guid>
        
        <category>Quantum</category>
        
        
        <category>prerequisites</category>
        
      </item>
    
      <item>
        <title>Computationally Visualizing Crystals Pt. 2</title>
        <description>&lt;h4 id=&quot;christina-c-lee-github-albi3ro&quot;&gt;Christina C. Lee, github: albi3ro&lt;/h4&gt;

&lt;p&gt;&lt;b&gt;Prerequisites:&lt;/b&gt; &lt;a href=&quot;/M4/ug/Crystal-Shapes.html&quot;&gt;Computationally Visuallizing Crystals Pt. 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Time to one-up the Bravais lattice from Part 1.  Many beautiful lattices don’t adhere to the “every site the same” policy.  They still repeat, but just take a little bit longer to get around to doing so.&lt;/p&gt;

&lt;p&gt;Take the Kagome Lattice below,&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/MultiUnit/kagomesvg.png&quot; alt=&quot;kagome&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;A Kagome Lattice.&lt;/p&gt;
    
&lt;/div&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/MultiUnit/kagomebasket.jpg&quot; alt=&quot;basket&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;A basket woven in the Japanese kagome style. &lt;sub&gt;Wikimedia commons&lt;/sub&gt;&lt;/p&gt;
    
&lt;/div&gt;

&lt;p&gt;If we look at the stars at the center of triangles, we can recognize a point triangular Bravais lattice.  Now each of those stars stands for a grouping of three sites in a &lt;i&gt;Unit Cell&lt;/i&gt;.  According to &lt;a href=&quot;http://chemwiki.ucdavis.edu/Physical_Chemistry/Physical_Properties_of_Matter/Phases_of_Matter/Solids/Unit_Cell&quot;&gt;Chem Wiki&lt;/a&gt;, a unit cell is:
&amp;gt;A unit cell is the most basic and least volume consuming repeating structure of any solid. It is used to visually simplify the crystalline patterns solids arrange themselves in.&lt;/p&gt;

&lt;p&gt;Now I chose these triangles to be be the unit cells above and in my computational representation below, but can you think of any other ways to represent the unit cell?&lt;/p&gt;

&lt;p&gt;Turns out, there isn’t a unique way.  We can go further and define the &lt;i&gt;Wigner-Seitz&lt;/i&gt; unit cell, which uses the Bravais translations to pick out just ONE of the various possible definitions.&lt;/p&gt;

&lt;p&gt;In my line of work though, we often use either the easiest to write down, or the one that has the symmetries we want.&lt;/p&gt;

&lt;h3 id=&quot;introducing-some-lattice-options&quot;&gt;Introducing Some Lattice Options&lt;/h3&gt;

&lt;p&gt;You saw Kagome above.&lt;/p&gt;

&lt;p&gt;The options I’ve put in now are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; honeycomb
&lt;li&gt; kagome
&lt;li&gt; shuriken aka Square-Kagome
&lt;li&gt; diamond
&lt;li&gt; pyrochlore


The ones implemented here, except for diamond, are frustrated lattices that I work with in my research. Honeycomb is well known in condensed matter physics for being the structure of graphene, an extremely important material right now, though I work with it in terms of the Kitaev spin model.  Kagome and Pyrochlore are also popular models within my community.  The shuriken lattice is more uncommon, but gaining ground in the frustration community.

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/MultiUnit/Shurikens.jpg&quot; alt=&quot;Shurikens&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Japanese Shurikens- a type of ninja fighting star. &lt;sub&gt;By kaex0r (http://www.flickr.com/photos/kaex0r414/191765028/) [CC BY 2.0 (http://creativecommons.org/licenses/by/2.0)], via Wikimedia Commons&lt;/sub&gt;&lt;/p&gt;
    
&lt;/div&gt;


```julia
# importing our packages
Pkg.add(&quot;PyPlot&quot;);
Pkg.update();
using PyPlot;
```



```julia
lattice=&quot;shuriken&quot;;

Nx=3;
Ny=3;
Nz=1;
```


```julia
# A cell to just evaluate
# This one sets the unit vectors (a,b,c) for the different unit cells
# Can you guess what a lattice will look like by looking at the vectors?
if(lattice==&quot;honeycomb&quot;) #also the graphite lattice
    d=2;
    Ncell=2;
    unit=[[0 0 0]
        [sqrt(3)/2 1/2 0]];
    a=[sqrt(3),0,0];
    b=[sqrt(3)/2,3/2,0];
    c=[0,0,1];
elseif(lattice==&quot;kagome&quot;)
    d=2;
    Ncell=3;
    unit=[[0 0 0]
          [1 0 0]
        [.5 sqrt(3)/2 0]];
    a=[2,0,0];       #Look familiar? Checkout pt from Pt. 1
    b=[1, sqrt(3), 0];
    c=[0,0,1];
elseif(lattice==&quot;shuriken&quot;)
    d=2;
    Ncell=6;
    unit=[[0 0 0]
          [.5 0 0]
          [0 .5 0]
          [.5 .5 0]
        [.5+.25*sqrt(3) .25 0]
        [.25 .5+.25*sqrt(3) 0]];
    a=[.5+.5*sqrt(3),0,0];
    b=[0,.5+.5*sqrt(3),0];
    c=[0,0,1];
elseif(lattice==&quot;diamond&quot;)
    d=3;
    Ncell=2;
    unit=[[0 0 0]
          [.25 .25 .25]];
    a=[.5,.5,0];    #Look familiar? Checkout fcc from Pt.1
    b=[.5,0,.5];
    c=[0,.5,.5];
elseif(lattice==&quot;pyrochlore&quot;)
    d=3;
    Ncell=4;
    unit=[[0 0 0]
        [.25 .25 0]
        [.25 0 .25]
        [0 .25 .25]];
    a=[.5,.5,0];
    b=[.5,0,.5];
    c=[0,.5,.5];

else
    println(&quot;Please have a correct lattice&quot;)
end
&quot;Cell finished&quot;
```



### Connections to Bravais Lattices

If look at some of the comments above, and checkout the basis vectors from Crystal Shapes, like pt,
        \begin{equation}
            a=[1,0,0]\;\;\;\;\;\;\;\;\; b=[.5,\frac{\sqrt{3}}{2},0],
        \end{equation}
you&#39;ll notice they&#39;re the same except for a scaling factor.  This has to be true, since only 14 different patterns tile 3D space uniquely.


```julia
# Another cell to just evaluate
# Here we set up some numbers and matrices for our computation
N=Nx*Ny*Nz*Ncell;    #The total number of sites
aM=transpose(repeat(a,outer=[1,Ncell]));
bM=transpose(repeat(b,outer=[1,Ncell*Nx])); #these allow us to copy an entire row or layer at once
cM=transpose(repeat(c,outer=[1,Ncell*Nx*Ny]));

X=Array{Float64}(N,3);  #where we store the positions
&quot;Cell finished&quot;
```




```julia
# Another cell to just evaluate
# Here we are actually calculating the positions for every site
for i in 1:Nx    #for the first row
    X[Ncell*i-Ncell+1:Ncell*i,:]=unit+(i-1)*aM;
end

for j in 2:Ny    #copying the first row into the first layer
    X[Ncell*Nx*(j-1)+(1:Ncell*Nx),:]=X[1:Ncell*Nx,:]+(j-1)*bM;
end

for j in 2:Nz    #copying the first layer into the entire cube
    X[Ncell*Ny*Nx*(j-1)+(1:Ncell*Nx*Ny),:]=X[1:Ncell*Nx*Ny,:]+(j-1)*cM;
end
&quot;Cell finished&quot;
```




```julia
# 2D plotter
pygui(false)
w, h = plt[:figaspect](1)
figure(figsize=(w,h))
scatter(X[:,1],X[:,2])
```


&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/MultiUnit/shurikenplot.png&quot; alt=&quot;Shuriken&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;3x3 Shuriken or Square-Kagome Lattice.&lt;/p&gt;
    
&lt;/div&gt;

```julia
# 3D plotter
pygui(false)
w, h = plt[:figaspect](1)
figure(figsize=(w,h))
areas=100*ones(length(X[:,1]))
scatter3D(X[:,1],X[:,2],X[:,3])
```





### Perdy Pictures
From these plots, some 3D structures like the pyrochlore are hard to visualize.  So here&#39;s a nice graphic I made that might help a little bit more.

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/MultiUnit/pyrochloresvg4.png&quot; alt=&quot;Pyrochlore&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Hopefully this pyrochlore is a little easier to visualize than the pyplot version.  Took me long enough to make in inkscape.&lt;/p&gt;
    
&lt;/div&gt;


&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/MultiUnit/honeycomb.png&quot; alt=&quot;honeycomb&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Tikz produced Honeycomb.  Coloring indicative of the lattice description of the Kitaev model.  &lt;/p&gt;
    
&lt;/div&gt;


The honeycomb, like several other lattices you see around here, is &lt;i&gt;bipartite&lt;/i&gt;.
You can see in my image that black sites are only next to white sites, and vice versa.
  This property can make the system much easier to work with.  What lattices are bipartite, and which ones aren&#39;t?

If you keep reading, these lattices will keep cropping up again and again.  I&#39;ll probably throw in some new ones as well.

Anyway, we will move onto some Quantum Mechanics to look at atomic orbitals soon!
&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
        <pubDate>Fri, 02 Jan 2015 00:00:00 +0900</pubDate>
        <link>/M4/general/MultiSite-Unit-Cells.html</link>
        <guid isPermaLink="true">/M4/general/MultiSite-Unit-Cells.html</guid>
        
        <category>Lattices</category>
        
        
        <category>general</category>
        
      </item>
    
      <item>
        <title>Computationally Visualizing Crystals</title>
        <description>&lt;h4 id=&quot;christina-c-lee-github-albi3ro&quot;&gt;Christina C. Lee, github: albi3ro&lt;/h4&gt;

&lt;p&gt;&lt;b&gt;Prerequisites:&lt;/b&gt; none&lt;/p&gt;

&lt;p&gt;In condensed matter, we find ourselves in the interesting middle ground of dealing with large numbers $10^{23}$ of extremely small particles, ex. atoms, electrons.&lt;/p&gt;

&lt;p&gt;Luckily, the particles don’t each do their own thing, but often come in nice, structured, repeated units.  &lt;i&gt;Lattices&lt;/i&gt;.  So as our first step into the field, we will look at the most basic type, a &lt;i&gt;Bravais Lattice&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;In a Bravais Lattice, every site looks like every other site. Mathematically, we use three vectors, $\vec{a},\vec{b},\vec{c}$ to express how we move from one site to a neighbor.&lt;/p&gt;

&lt;p&gt;\begin{equation}
\mathbf{R}_{lmn}=l \vec{a} + m \vec{b} + n \vec{c}  \;\;\;\; \text{for } l,m,n \in \mathbb{N}
\end{equation}&lt;/p&gt;

&lt;p&gt;To keep things working out right, we have to put a constraint on these vectors; that we can’t get one from scaling and adding the other two.  If we could, then we couldn’t put sites in an entire 3 dimensional space.&lt;/p&gt;

&lt;p&gt;Stay tuned for a later post where we explore more elaborate lattices.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;julia
# importing our packages
Pkg.add(&quot;PyPlot&quot;);
Pkg.update();
using PyPlot;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;define-the-relevant-variables&quot;&gt;Define The Relevant Variables&lt;/h2&gt;

&lt;p&gt;Choose the lattice you want to look at, and put that string into the lattice variable.
Current options:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt; Simple Cubic = &quot;sc&quot;
    &lt;li&gt; Plane triangular lattice = &quot;pt&quot;
    &lt;li&gt; Body-Centered Cubic = &quot;bcc&quot;
    &lt;li&gt; Face-Centered Cubic = &quot;fcc&quot;
Note: Square is Simple Cubic for Nz=1


14 distinct lattice types are possible, but these common four give the important ideas.

Also, input the size of lattice you want to look at.


```julia
lattice=&quot;sc&quot;;

Nx=3;
Ny=3;
Nz=3;
```


```julia
# A cell to just evaluate
# This one sets the unit vectors (a,b,c) for the different unit cells
# Can you guess what a lattice will look like by looking at the vectors?
if(lattice==&quot;sc&quot;)
    d=3;
    a=[1,0,0];
    b=[0,1,0];
    c=[0,0,1];
elseif(lattice==&quot;pt&quot;)
    d=2;
    a=[1,0,0];
    b=[.5,sqrt(3)/2,0];
    c=[0,0,1];
elseif(lattice==&quot;bcc&quot;)
    d=3;
    a=[.5,.5,.5];
    b=[.5,.5,-.5];
    c=[.5,-.5,.5];
elseif(lattice==&quot;fcc&quot;)
    d=3;
    a=[.5,.5,0];
    b=[.5,0,.5];
    c=[0,.5,.5];
else
    println(&quot;Please have a correct lattice&quot;)
end
```




```julia
# Another cell to just evaluate
# Here we set up some numbers and matrices for our computation
N=Nx*Ny*Nz;    #The total number of sites
aM=transpose(a);
bM=transpose(repeat(b,outer=[1,Nx])); #these allow us to copy an entire row or layer at once
cM=transpose(repeat(c,outer=[1,Nx*Ny]));

X=Array{Float64}(N,3);  #where we store the positions
```





```julia
# Another cell to just evaluate
# Here we are actually calculating the positions for every site
for i in 1:Nx    #for the first row
    X[i,:]=(i-1)*a;
end

for j in 2:Ny    #copying the first row into the first layer
    X[Nx*(j-1)+(1:Nx),:]=X[1:Nx,:]+(j-1)*bM;
end

for j in 2:Nz    #copying the first layer into the entire cube
    X[Ny*Nx*(j-1)+(1:Nx*Ny),:]=X[1:Nx*Ny,:]+(j-1)*cM;
end
```
&lt;div class=&quot;progtip&quot;&gt;
&lt;h3 color=&quot;black&quot;&gt; Programming Tip:&lt;/h3&gt;
 &lt;p&gt;In Julia, ranges, like &lt;code&gt;1:Nx&lt;/code&gt;, are a special variable type that can be manipulated.  We can add numbers to them:
 &lt;code&gt;3+(1:3)=4:6&lt;/code&gt;,
 or add a minus sign to force it to iterate in the opposite direction, though with different start/stop:
 &lt;code&gt;-(1:3)=-1:-1:-3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;
 &lt;span color=&quot;#000000&quot;&gt;Danger!&lt;/span&gt; Make sure to use the parentheses around the range if you are performing these operations.&lt;/p&gt;
&lt;/div&gt;


```julia
pygui(false);  #if true, launches new window with interactive capabilities

drawcube=true;  #gives lines for a cube, helps interpret the dots
ls=2;  # how many cubes to draw
if(drawcube==true)
    v=collect(0:ls);
    zed=zeros(v);
    for i in 0:ls
        for j in 0:ls
            plot3D(zed+i,v,zed+j)
            plot3D(zed+i,zed+j,v)

            plot3D(v,zed+i,zed+j)
            plot3D(zed+j,zed+i,v)

            plot3D(v,zed+j,zed+i)
            plot3D(zed+j,v,zed+i)
        end
    end
end

scatter3D(X[:,1],X[:,2],X[:,3],s=200*ones(X[:,1]),alpha=1)
```

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/CrystalShapes/sc.png&quot; alt=&quot;sc&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Simple Cubic: The easiest lattice out there short of the 1D chain.&lt;/p&gt;
    
&lt;/div&gt;


&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/CrystalShapes/pt.png&quot; alt=&quot;pt&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Point Triangular: A 2D lattice.  Plotted using scatter instead of scatter3D.&lt;/p&gt;
    
&lt;/div&gt;


&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/CrystalShapes/bcc.jpg&quot; alt=&quot;bcc&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Body Centered Cubic:  Notice how some sites fall on the cubic lattice, but others fall in between.  Generated with pygui(true) and then manipulating in 3D.&lt;/p&gt;
    
&lt;/div&gt;


&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/M4/Images/CrystalShapes/fcc.jpg&quot; alt=&quot;fcc&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;Face Centered Cubic: Here the sites either fall on the the cubic corners of in the center of the sides.   Generated with pygui(true), ls=1, and then manipulating in 3D.&lt;/p&gt;
    
&lt;/div&gt;


## Go Back and Fiddle!

As you might have noticed, this isn&#39;t just a blog where you just read through it.  Interact with it.  Change some lines, and see what happens.  I choose body centered cubic to display first, but what do the other lattices look like?

Chose `pygui(true)` to pop open a window and manipulate the plot in 3D.

Look at different lattice sizes.

Can you hand draw them on paper?

&lt;center&gt;![Mydrawing](/M4/Images/CrystalShapes/handdraw2.jpg)&lt;/center&gt;


Let me know what you think, and enjoy the sequel as well!
## [&lt;center&gt;&lt;i&gt; Multi-site unit cells&lt;/i&gt;&lt;/center&gt;](/M4/undergrad/MultiSite-Unit-Cells.html)
&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
        <pubDate>Thu, 01 Jan 2015 00:00:00 +0900</pubDate>
        <link>/M4/general/Crystal-Shapes.html</link>
        <guid isPermaLink="true">/M4/general/Crystal-Shapes.html</guid>
        
        <category>Lattices</category>
        
        
        <category>general</category>
        
      </item>
    
  </channel>
</rss>
